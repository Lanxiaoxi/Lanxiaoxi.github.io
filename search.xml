<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SSM整合实现登陆功能]]></title>
    <url>%2Flanxi.github.io%2F2019%2F05%2F15%2FSSM%E6%95%B4%E5%90%88%E5%AE%9E%E7%8E%B0%E7%99%BB%E9%99%86%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[总体整合思路 整合的核心就是通过spring管理springmvc和mabatis，spring相当于一个管家 表现层，也就是 Controller,由 SpringMVC 来控制，而SpringMVC 是Spring 的一个模块，故不需要整合 业务层，也就是 service，通常由 Spring 来管理 service 接口，我们会使用 xml 配置的方式来将 service 接口配置到 spring 配置文件中。而且事务控制一般也是在 service 层进行配置 持久层，也就是 dao 层，而且包括实体类，由 MyBatis 来管理，通过 spring 来管理 mapper 接口，使用mapper的扫描器自动扫描mapper接口在spring中进行注册 准备环境 mysql5.6+tomcat9.0+IDEA+jdk1.8 项目结构 项目构建 使用maven进行构建web项目，步骤略 构造完毕后添加所需要所有jar包的依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.xxx&lt;/groupId&gt; &lt;artifactId&gt;webmvc01&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;webmvc01 Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;spring.version&gt;4.3.3.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- 添加数据库连接池dbcp包 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 加入ServletAPI --&gt; &lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.3&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- MySQL依赖 start --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySQL依赖 end --&gt; &lt;!-- 加入MyBatis 依赖 start --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.2.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 加入MyBatis 依赖 end --&gt; &lt;!-- Log4j start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 引入Spring(包含SpringMVC) 依赖 start --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 引入Spring 依赖 end --&gt; &lt;!-- 引用c3p0 依赖 start--&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.2.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 引用c3p0 依赖 end--&gt; &lt;!-- 引用插件依赖：MyBatis整合Spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSTL --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;webmvc01&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; 整合spring和mabatis配置mabatis全局配置文件 mybatis-configuration.xml 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 全局 setting 配置，根据需要添加 --&gt; &lt;!--开启二级缓存 --&gt; &lt;settings&gt; &lt;setting name="cacheEnabled" value="true"/&gt; &lt;/settings&gt; &lt;!-- 配置别名 --&gt; &lt;typeAliases&gt; &lt;!-- 批量扫描别名 --&gt; &lt;package name="wk.po"/&gt; &lt;/typeAliases&gt; &lt;!-- 配置mapper,由于使用 spring 和mybatis 的整合包进行 mapper 扫描，这里不需要配置了 必须遵循：mapper.xml 和 mapper.java 文件同名且在同一个目录下 --&gt; &lt;!-- &lt;mappers&gt;&lt;/mappers&gt; --&gt; &lt;/configuration&gt; xxxMapper 接口必须要和 xxxMapper.xml 文件同名且在同一个包下，也就是说 UserMapper.xml 文件中的namespace是UserMapper接口的全类名 xxxMapper接口中的方法名和 xxxMapper.xml 文件中定义的 id 一致 xxxMapper接口输入参数类型要和 xxxMapper.xml 中定义的 + parameterType 一致 xxxMapper接口返回数据类型要和 xxxMapper.xml 中定义的 resultType 一致 配置spring-dao文件为试条目清晰所以创建了多个spring的配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd"&gt; &lt;!--第一步： 配置数据源 --&gt; &lt;!-- 加载db.properties文件中的内容,db.properties文件中的key名要有一定的特殊性,如果没有用配置文件则可以直接写入文档当中 --&gt; &lt;context:property-placeholder location="classpath:db.properties" /&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driver&#125;"&gt;&lt;/property&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"&gt;&lt;/property&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt; &lt;property name="maxActive" value="30"&gt;&lt;/property&gt; &lt;property name="maxIdle" value="5"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 第二步：创建sqlSessionFactory。生产sqlSession --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;!-- 加载mybatis全局配置文件,注意这个文件的目录 --&gt; &lt;property name="configLocation" value="classpath:mybatis-configuration.xml"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 第三步：配置 mapper 扫描器 * 接口类名和映射文件必须同名 * 接口类和映射文件必须在同一个目录下 * 映射文件namespace名字必须是接口的全类路径名 * 接口的方法名必须和映射Statement的id一致 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!-- 扫描的包路径，如果需要扫描多个包，中间使用逗号分隔 --&gt; &lt;property name="basePackage" value="wk.mapper"&gt;&lt;/property&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; 创建pojo类以及相应的mapper文件，记住遵循四项规则才可以进行动态扫描 UserMapper.java 1234567891011121314package wk.mapper; import wk.po.User;import java.util.List;import org.apache.ibatis.annotations.Param; public interface UserMapper &#123; //通过用户名和密码查询User User selectUserByUsernameAndPassword(User user); &#125; UserMapper.xml 12345&lt;!-- 通过用户名和密码查询User --&gt; &lt;select id="selectUserByUsernameAndPassword" resultType="wk.po.User" parameterType="wk.po.User"&gt; select * from user where username = #&#123;username,jdbcType=VARCHAR&#125; and password = #&#123;password,jdbcType=VARCHAR&#125; &lt;/select&gt; dao层整合完毕之后可以利用单元测试来进行测试 这里的测试内容可以根据实际数据库情况来进行编写 12345678910111213141516171819202122232425262728293031package wk.test; import org.junit.Before;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext; import wk.mapper.UserMapper;import wk.po.User; public class DaoTest &#123; ApplicationContext context = null; @Before public void init()&#123; context = new ClassPathXmlApplicationContext("classpath:application-dao.xml"); &#125; @Test public void testSelectByPrimaryKey()&#123; UserMapper userMapper = (UserMapper) context.getBean("userMapper"); User user = userMapper.selectByPrimaryKey(1); System.out.println(user.getPassword()); &#125; &#125; 整合service这层就是用 Spring 来管理 service 接口，我们会使用 xml 配置的方式来将 service 接口配置到 spring 配置文件中。而且事务控制也是在 service 层进行配置 编写service接口和实现类 12345678910package wk.service.impl; import wk.po.User; public interface IUserService &#123; //通过用户名和密码查询User public User selectUserByUsernameAndPassword(User user); &#125; 12345678910111213141516171819202122package wk.service; import org.springframework.beans.factory.annotation.Autowired; import com.ys.mapper.UserMapper;import com.ys.po.User;import com.ys.service.impl.IUserService; public class UserServiceImpl implements IUserService&#123; @Autowired private UserMapper userMapper; //通过@Autowired向spring容器注入UserMapper //通过用户名和密码查询User @Override public User selectUserByUsernameAndPassword(User user) &#123; User u = userMapper.selectUserByUsernameAndPassword(user); return u; &#125; &#125; 在spring容器中配置接口 1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd"&gt; &lt;!--配置UserServiceImpl --&gt; &lt;bean id="userService" class="com.ys.service.UserServiceImpl"&gt;&lt;/bean&gt; &lt;/beans&gt; 在spring中配置事务 建立新的spring配置文件 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd"&gt; &lt;!-- 事务管理器 --&gt; &lt;!-- 对mybatis操作数据事务控制，spring使用jdbc的事务控制类 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;!-- 数据源dataSource在spring-dao.xml中配置了 --&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!-- 通知 --&gt; &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="save*" propagation="REQUIRED"/&gt; &lt;tx:method name="delete*" propagation="REQUIRED"/&gt; &lt;tx:method name="update*" propagation="REQUIRED"/&gt; &lt;tx:method name="insert*" propagation="REQUIRED"/&gt; &lt;tx:method name="find*" propagation="SUPPORTS" read-only="true"/&gt; &lt;tx:method name="get*" propagation="SUPPORTS" read-only="true"/&gt; &lt;tx:method name="select*" propagation="SUPPORTS" read-only="true"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;aop:config&gt; &lt;!-- com.ys.service.impl包里面的所有类，所有方法，任何参数 --&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut="execution(* wk.service.impl.*.*(..))"/&gt; &lt;/aop:config&gt; &lt;/beans&gt; 整合springmvc 配置前端控制器 1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" id="WebApp_ID" version="3.0"&gt; &lt;display-name&gt;SpringMVC_01&lt;/display-name&gt; &lt;!-- 配置前端控制器DispatcherServlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--springmvc.xml 是自己创建的SpringMVC全局配置文件，用contextConfigLocation作为参数名来加载 如果不配置 contextConfigLocation，那么默认加载的是/WEB-INF/servlet名称-servlet.xml，在这里也就是 springmvc-servlet.xml --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!--第一种配置：*.do,还可以写*.action等等，表示以.do结尾的或者以.action结尾的URL都由前端控制器DispatcherServlet来解析 第二种配置：/,所有访问的 URL 都由DispatcherServlet来解析，但是这里最好配置静态文件不由DispatcherServlet来解析 错误配置：/*,注意这里是不能这样配置的，应为如果这样写，最后转发到 jsp 页面的时候，仍然会由DispatcherServlet进行解析， 而这时候会找不到对应的Handler，从而报错！！！ --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 配置配置处理器映射器、处理器适配器、视图解析器 12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!--使用mvc:annotation-driven可以代替上面的映射器和适配器 这里面会默认加载很多参数绑定方法，比如json转换解析器就默认加载，所以优先使用下面的配置 --&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;!--批量配置Handler,指定扫描的包全称 --&gt; &lt;context:component-scan base-package="wk.controller"&gt;&lt;/context:component-scan&gt; &lt;!--配置视图解析器 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;/bean&gt;&lt;/beans&gt; 编写handler 1234567891011121314151617181920212223242526272829package wk.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import wk.po.User;import wk.service.impl.IUserService;@Controllerpublic class UserController &#123; @Autowired private IUserService userService; @RequestMapping("/login") public ModelAndView login(User user)&#123; System.out.println(user); ModelAndView mv = new ModelAndView(); User u = userService.selectUserByIdAndPwd(user); System.out.println(u.getUsername()); if (u != null) &#123; mv.addObject("username",u.getUsername()); mv.addObject("user",u); mv.setViewName("view/success.jsp"); &#125;else &#123; return new ModelAndView("redirect:/login.jsp"); &#125; return mv; &#125;&#125; 加载spring容器 在web.xml文件中加入下面的代码 12345678&lt;!-- 加载spring容器 --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/spring-*.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 最后测试 使用login和sucesss两个jsp页面来测试是否登陆成功 在配置是注意两个页面的位置，login是在WEB-INF下面的，而success页面实在view文件夹下面 12345678910111213141516171819&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="login" method="post"&gt; &lt;label&gt;账号：&lt;/label&gt; &lt;input type="text" id="txtUsername" name="username" placeholder="请输入账号" /&gt;&lt;br/&gt; &lt;label&gt;密码：&lt;/label&gt; &lt;input type="password" id="txtPassword" name="password" placeholder="请输入密码" /&gt;&lt;br/&gt; &lt;input type="submit" value="提交" /&gt; &lt;input type="reset" value="重置" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; Hello $&#123;user.username&#125;&lt;/body&gt;&lt;/html&gt; 遇到的问题 在写mapper文件的时候查询出现空指针 可能是查询mapper文件中的查询字段和数据库中的以及pojo类中的相应的字段名称不一致造成 isELIgnored=”false”解决jsp页面，显示出Hello ${user.username}的问题]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于mybatis入门的简单总结]]></title>
    <url>%2Flanxi.github.io%2F2019%2F05%2F11%2F%E5%85%B3%E4%BA%8Emybatis%E5%85%A5%E9%97%A8%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Mybatis简单配置导入mabatis包 mybatis核心配置文件+ 所连接数据库的相关信息 + 所关联的mapper信息【路经是相对于calsspath来说的】 1234567891011121314151617181920212223242526272829303132 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;!-- 引入外部配置文件 --&gt; &lt;!-- 配置mybatis运行环境 --&gt; &lt;environments default=&quot;cybatis&quot;&gt; &lt;environment id=&quot;cybatis&quot;&gt; &lt;!-- type=&quot;JDBC&quot; 代表使用JDBC的提交和回滚来管理事务 --&gt; &lt;transactionManager type=&quot;JDBC&quot; /&gt; &lt;!-- mybatis提供了3种数据源类型，分别是：POOLED,UNPOOLED,JNDI --&gt; &lt;!-- POOLED 表示支持JDBC数据源连接池 --&gt; &lt;!-- UNPOOLED 表示不支持数据源连接池 --&gt; &lt;!-- JNDI 表示支持外部数据源连接池 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybaits&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot; /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;mybaits/userdao.xml&quot; /&gt; &lt;/mappers&gt;&lt;/configuration&gt; 两种方式配置操作数据库 传统的dao方式-实现dao接口和相应的实现类 使用mapper的动态代理方式【推荐】 两种方式的实现配置差别在于mapper标签的namespace属性，如果使用对应的接口的路径作为namespace属性的值，则此时使用的是动态代理方式，同时必须遵循四项规定 方法名 === User.xml中的id名 返回值类型与Mapper.xml中返回类型一致 方法入参类型与Mapper.xml中入参的类型一致 接口的路径作为namespace属性的值 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapperPUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.sss.UserMap&quot;&gt;&lt;select id=&quot;finduserbyid&quot; parameterType=&quot;Integer&quot; resultType=&quot;com.sss.User&quot;&gt;select * from t_user where id = #&#123;i&#125;&lt;/select&gt;&lt;select id=&quot;finduserbyname&quot; parameterType=&quot;String&quot; resultType=&quot;com.sss.User&quot;&gt;select * from t_user where name = #&#123;n&#125;&lt;/select&gt;&lt;insert id=&quot;adduser&quot; parameterType=&quot;com.sss.User&quot; &gt;insert into t_user (id,name) values (#&#123;id&#125;,#&#123;name&#125;)&lt;/insert&gt;&lt;update id=&quot;updatauser&quot; parameterType=&quot;com.sss.User&quot; &gt;update t_user set id = #&#123;id&#125;, name = #&#123;name&#125; where id = #&#123;id&#125;&lt;/update&gt;&lt;delete id=&quot;deleteuser&quot; parameterType=&quot;Integer&quot; &gt;delete from t_user where id = #&#123;id&#125;&lt;/delete&gt;&lt;/mapper&gt; 在其中有几个相对重要的标签属性，首先id，parameterType作为输入类型的标签，resultType做为返回类型的标签，返回类型如果是摸一个类则路径必须写完全 配置完后的一个示例1234567891011121314151617181920212223 @Test public void demo02() throws IOException &#123; String resource = &quot;mybaits/mybaitscfg.xml&quot;; InputStream in = Resources.getResourceAsStream(resource); sf = new SqlSessionFactoryBuilder().build(in); SqlSession ss = sf.openSession(); UserMap userMap = ss.getMapper(UserMap.class); User u = userMap.finduserbyid(1); System.out.println(u); &#125; ``` 1. 加载mybatis核心配置文件2. 通过SqlSessionFactoryBuilder().build(in);构建session工厂3. 通过session工厂创建session会话4. 通过session会话取得mapper5. 执行操作ps：SqlSessionFactoryBuilder()的5种创造方法 SqlSessionFactory build(InputStream inputStream) SqlSessionFactory build(InputStream inputStream, String environment) SqlSessionFactory build(InputStream inputStream, Properties properties) SqlSessionFactory build(InputStream inputStream, String env, Properties props) SqlSessionFactory build(Configuration config) ` 在配置mybatis的同时也可以用注解的方式，参见W3cschool，mybatis教程]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring总结]]></title>
    <url>%2Flanxi.github.io%2F2019%2F05%2F08%2FSpring%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Springspring介绍 spring在三层web，service，以及dao层中横贯三个层次，负责管理项目中的所有对象，可以看最项目的管家 正是因为spring框架性质是属于容器性质的. 不仅不排斥其他框架,还能帮其他框架管理对象. aop支持 ioc思想 spring jdbc aop 事务 junit 测试支持 简单项目搭建 导包 创建一个对象 书写配置文件注册对象到容器里面 配置文件建议放在src下面 spring基本概念两个重要思想 ioc 控制反转通过控制反转，对象的创建和管理，以及他们之间的相互依赖关系都由spring来完成 di 依赖注入注入方式主要有三种，set方法注入，构造注入和字段注入等，注入类型主要分为两种，值类型和引用类型 获取bean的两种方式 BeanFactory接口 spring原始接口.针对原始接口的实现类功能较为单一 BeanFactory接口实现类的容器.特点是每次在获得对象时才会创建对象 ApplicationContext 每次容器启动时就会创建容器中配置的所有对象.并提供更多功能丛类路径下加载配置文件:ClassPathXmlApplicationContext从硬盘绝对路径下加载配置文件:FileSystemXmlApplicationContext(“d:/xxx/yyy/xxx”) 结论:web开发中,使用applicationContext. 在资源匮乏的环境可以使用BeanFactory. spring配置详解bean元素 bean元素配置主要用bean标签，属性有name，class，id等 Bean元素进阶+ scope属性 singleton(默认值):单例对象.被标识为单例的对象在spring容器中只会存在一个实例 prototype:多例原型.被标识为多例的对象,每次再获得才会创建.每次创建都是新的对象.整合struts2时,ActionBean必须配置为多例的. request:web环境下.对象与request生命周期一致. session:web环境下,对象与session生命周期一致. + 生命周期属性 配置一个方法作为生命周期初始化方法.spring会在对象创建之后立即调用. init-method 配置一个方法作为生命周期的销毁方法.spring容器在关闭并销毁所有容器中的对象之前调用. destory-method spring创建对象的方式1.空参构造方式 2.静态工厂(了解) 3.实例工厂(了解) spring还可以通过import标签来导入其他xml配置文件 spring属性注入对于基本类型，Spring容器会自动作类型转换，以便赋值。 注入方式 set方法注入 &lt;beans&gt; &lt;bean id=”BeanId” class=”classpath” autowire=” ” dependency-check=” ”&gt; &lt;property name=”parameterName”&gt; &lt;value&gt;parameterValue&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 构造函数注入 p名称空间注入 spel注入 复杂类型注入 数组 List Map Properties spring的AOP AOP(Aspect-oriented programming,面向切面编程)： 什么是AOP？ 定义：将程序中的交叉业务逻辑提取出来，称之为切面。将这些切面动态织入到目标对象，然后生成一个代理对象的过程。 AOP核心概念 Aspect（切面） 切面，切入点+通知 Joinpoint（连接点） 连接点，指切面可以织入到目标对象的位置（方法，属性等）。 解释：目标对象中所有可以加强的方法 Advice（通知） 通知，指切面的具体实现。 解释：增强的代码 Pointcut（切入点） 切入点，指通知应用到哪些类的哪些方法或属性之上的规则。 解释：目标对象中已经加强的方法 Introduction（引入） 引入，指动态地给一个对象增加方法或属性的一种特殊的通知。 Weaving（织入） 织入，指将通知插入到目标对象。 Target（目标对象） 目标对象，指需要织入切面的对象。 Proxy（代理对象） 代理对象，指切面织入目标对象之后形成的对象。 Spring AOP原理 采用动态代理模式。 Spring AOP采用动态代理的过程： 将切面使用动态代理的方式动态织入到目标对象（被代理类），形成一个代理对象； 目标对象如果没有实现代理接口，那么Spring会采用CGLib来生成代理对象，该代理对象是目标对象的子类； 目标对象如果是final类，并且也没实现代理接口，就不能运用AOP。 Spring的通知Spring的通知类型 MethodBeforeAdvice 类全名：org.springframework.aop.MethodBeforeAdvice 在方法调用之前，做处理。 不能够改变返回值 不能够改变目标方法的流程，也不能中断流程的处理过程（除非抛出异常） AfterReturningAdvice 类全名：org.springframework.aop.AfterReturningAdvice 在方法调用之后，做处理。 不能够改变返回值 不能够改变目标方法的流程，也不能中断流程的处理过程（除非抛出异常） MethodInterceptor 类全名：org.aopalliance.intercept.MethodInterceptor 在方法调用之前以及之后，做处理。 可以改变返回值，也可以改变流程。 ThrowsAdvice 类全名：org.springframework.aop.ThrowsAdvice 在方法抛出异常后，做处理。 当该通知处理完异常后，会简单地将异常再次抛出给目标调用方法。 配置过程： 配置目标对象 配置通知 利用ProxyFactoryBean将通知织入到目标对象，形成一个动态代理对象 客户端使用动态代理来访问目标对象的方法。 在默认情况下，通知会应用到所有的方法之上。 Pointcut： 根据方法和类决定在什么地方织入通知 Advisor： 将Pointcut与Advice结合到一起。 5. 为什么要使用spring 因为只要是OOP开发的应用，都是由对象与对象之间进行协作进行工作的，那么对象与对象之间的关系管理（依赖关系）如果需要自己用代码进行维护很麻烦。用了Spring就可以省去这麻烦的工作了 Spring是独特的,因为若干个原因: ◆它定位的领域是许多其他流行的framework没有的。Spring关注提供一种方法管理你的业务对象。 ◆ Spring是全面的和模块化的。Spring有分层的体系结构,这意味着你能选择使用它孤立的任何部分,它的架构仍然是内在稳定的。因此从你的学习中，你可得到最大的价值。例如,你可能选择仅仅使用Spring来简单化JDBC的使用,或用来管理所有的业务对象。 ◆它的设计从底部帮助你编写易于测试的代码。Spring是用于测试驱动工程的理想的framework。 Spring对你的工程来说，它不需要一个以上的framework。Spring是潜在地一站式解决方案，定位于与典型应用相关的大部分基础结构。它也涉及到其他framework没有考虑到的内容。 6. spring的目的？意义？ ◆目的：解决企业应用开发的复杂性 ◆功能：使用基本的JavaBean代替EJB，并提供了更多的企业应用功能 ◆范围：任何Java应用 意义：1,降低开发成本.2,方便使用. 7. spring的优缺点 1. 提供了一种管理对象的方法，可以把中间层对象有效地组织起来。一个完美的框架“黏合剂”。 2. 采用了分层结构，可以增量引入到项目中。 3. 有利于面向接口编程习惯的养成。 4. 目的之一是为了写出易于测试的代码。 5. 非侵入性，应用程序对Spring API的依赖可以减至最小限度。 6. 一致的数据访问介面。 7. 一个轻量级的架构解决方案。 8. 缺点：目前不支持集群 8. spring带给我们什么 ◆方便解耦，简化开发 通过Spring提供的IoC容器，我们可以将对象之间的依赖关系交由Spring进行控制，避免硬编码所造成的过度程序耦合。有了Spring，用户不必再为单实例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。 ◆AOP编程的支持 通过Spring提供的AOP功能，方便进行面向切面的编程，许多不容易用传统OOP实现的功能可以通过AOP轻松应付。 ◆声明式事务的支持 在Spring中，我们可以从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活地进行事务的管理，提高开发效率和质量。 ◆方便程序的测试 可以用非容器依赖的编程方式进行几乎所有的测试工作，在Spring里，测试不再是昂贵的操作，而是随手可做的事情。 ◆方便集成各种优秀框架 Spring不排斥各种优秀的开源框架，相反，Spring可以降低各种框架的使用难度，Spring提供了对各种优秀框架（如Struts,Hibernate、Hession、Quartz）等的直接支持。 ◆降低Java EE API的使用难度 Spring对很多难用的Java EE API（如JDBC，JavaMail，远程调用等）提供了一个薄薄的封装层，通过Spring的简易封装，这些Java EE API的使用难度大为降低。 ◆Java 源码是经典学习范例 9. spring能做什么 Spring的主要目的是使J2EE易用和促进好编程习惯。 Spring的目标是使已存在的技术更加易用。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>-java -spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matlab学习笔记---线性规划和非线性规划（五）]]></title>
    <url>%2Flanxi.github.io%2F2019%2F05%2F06%2FMatlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"></content>
      <categories>
        <category>MATLAB</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matlab学习笔记--插值·拟合和回归分析（四）]]></title>
    <url>%2Flanxi.github.io%2F2019%2F05%2F06%2FMatlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%8F%92%E5%80%BC%C2%B7%E6%8B%9F%E5%90%88%E5%92%8C%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数据建模 关于数据挖掘和建模的一些基本方法，用于插值拟合回归分析等 预备知识插值 分段性插值 最简单的插值方法，直观上就是把各数据点用折线连接起来，形成收敛的曲线但是不光滑 多项式插值 利用拉格朗日插值公式，虽然插值光滑但是不具有收敛性 样条插值 最小二乘拟合 多元线性回归 matlab指令多项式插值和拟合x = 0.1000 0.2000 0.1500 0 -0.2000 0.3000 y = 0.9500 0.8400 0.8600 1.0600 1.5000 0.7200 p = polyfit(x,y,2)//用k次多项式拟合向量（x，y），返回多项式的降幂系数，当k&gt;=n-1时，polyfit实现多项式插值 p = 1.7432 -1.6959 1.085 p[1]x^2+p[2]x+p[3]]]></content>
      <categories>
        <category>MATLAB</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matlab学习笔记--矩阵代数（三）]]></title>
    <url>%2Flanxi.github.io%2F2019%2F04%2F29%2FMatlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%9F%A9%E9%98%B5%E4%BB%A3%E6%95%B0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[矩阵代数 线性代数 矩阵代数的matlab指令 计算实验 建模试验 线性代数 作为工科基础必修课程，不再赘述。 矩阵代数的matlab指令矩阵运算符 转置—-A.’ 共轭转置—-A’//当A为实矩阵的时候等价于矩阵转置 加减—-A+/-B 数与矩阵加减—-k+/-A 数乘矩阵—-A*k 矩阵乘法—-A*B 矩阵乘方—-A^k 矩阵除法—-A/\B 特殊矩阵的生成 四个主要方法 A = zeros(2,2) A = 0 0 0 0 ones(3,2); ans = 1 1 1 1 1 1 eye(3) ans = 1 0 0 0 1 0 0 0 1 rand(3,2)//生成m行n列的0-1随机数 ans = 0.8147 0.9134 0.9058 0.6324 0.1270 0.0975 矩阵处理 B =rand(4,4) B = 0.2785 0.1576 0.8003 0.7922 0.5469 0.9706 0.1419 0.9595 0.9575 0.9572 0.4218 0.6557 0.9649 0.4854 0.9157 0.0357 trace(B)//对角线之和 trace(B)错误使用 trace (line 12)矩阵必须为方阵。 ans = 1.7066 diag(B)//返回对角线元素对应的向量 ans = 0.2785 0.9706 0.4218 0.0357 tril(B)//矩阵下三角化 ans = 0.2785 0 0 0 0.5469 0.9706 0 0 0.9575 0.9572 0.4218 0 0.9649 0.4854 0.9157 0.0357 triu(B)//矩阵上三角化 ans = 0.2785 0.1576 0.8003 0.7922 0 0.9706 0.1419 0.9595 0 0 0.4218 0.6557 0 0 0 0.0357 flipud(B)//矩阵上下反转 ans = 0.9649 0.4854 0.9157 0.0357 0.9575 0.9572 0.4218 0.6557 0.5469 0.9706 0.1419 0.9595 0.2785 0.1576 0.8003 0.7922 fliplr(B)//矩阵左右反转 ans = 0.7922 0.8003 0.1576 0.2785 0.9595 0.1419 0.9706 0.5469 0.6557 0.4218 0.9572 0.9575 0.0357 0.9157 0.4854 0.9649 reshape(B,2,8)//将矩阵重新排列为2行8列 ans = 0.2785 0.9575 0.1576 0.9572 0.8003 0.4218 0.7922 0.6557 0.5469 0.9649 0.9706 0.4854 0.1419 0.9157 0.9595 0.0357 矩阵分析A = 1 2 3 4 rank(A)//求秩 ans = 2 det(A)//求行列式 ans = -2 inv(A)//求逆矩阵 ans = -2.0000 1.0000 1.5000 -0.5000 orth(A)//求其列向量空间的正交规范基 ans = -0.4046 -0.9145 -0.9145 0.4046 x = 1 2 norm(x)//求向量或者矩阵的范数 ans = 2.2361 expm(A)//求矩阵A的指数函数 ans = 51.9690 74.7366 112.1048 164.0738 特征值与标准型A = 1 2 3 4 poly(A)//返回A的特征多项式的系数，次数由高到低 ans = 1.0000 -5.0000 -2.0000 [V,D]=eig(A) %返回A的特征值和特征向量，D为特征值构成的的对角矩阵，每个特征值对应的V的列属于该特征值的一个特征向量，如果只有一个返回变量则只返回特征值构成的列向量 V = -0.8246 -0.4160 0.5658 -0.9094 D = -0.3723 0 0 5.3723]]></content>
      <categories>
        <category>MATLAB</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matlab学习笔记--编程与作图（二）]]></title>
    <url>%2Flanxi.github.io%2F2019%2F04%2F29%2FMatlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BC%96%E7%A8%8B%E4%B8%8E%E4%BD%9C%E5%9B%BE%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[编程与作图 程序设计 作图 在线帮助和文件管理 主要学习设计方法和作图方法 程序设计控制流 控制流语法都以end结尾 循环语句 for循环 for 循环变量=数组 指令集；end while循环 while 条件式，指令组；end 分支语句 if else if 条件式，指令组；elseif 条件式，指令组；end switch switch 分支变量，case 值，指令组；otherwise，指令组；end 中断语句 pause 暂停执行直到敲击键盘，或者可以指定暂停的时间 break 中断执行用于在循环中终止循环 return 放回主调函数或者指令窗口 error（） 提示错误并且显示字符串说明 M脚本文件 M脚本文件 M函数文件 在脚本编辑框里面进行书写，之后会保存为.m结尾的文件，在命令行中直接输入名称调用，在每次调用的时候都要先保存 ps .m文件不区分大小写 函数文件为了解决脚本文件没有参数传递的功能，函数文件可以有多个输入和输出值 M函数文件以function开头，格式为 function [输出变量] = 函数名（输入变量） 语句; 与脚本文件的区别 该函数文件可以被其他脚本和函数调用 在函数之中的变量的作用范围仅限于在函数内部 函数句柄·inline函数和匿名函数 函数句柄可以看作是函数在命令行中的另一个命名 简单函数不用写为函数文件直接使用inline函数或者匿名函数使用格式为 fun=inline(‘expr’,arg1,arg2,····)其中expr为函数表达式，arg为自变量，用fun来调用 匿名函数的使用格式 示例k=3;fname=@ (m)sum(1./(1:m).^k);调用时直接调用fname(xxx) 其他 input用来读取键盘输入 disp用来屏幕输出 matlab执行循环语句的速度相对比较慢 作图通过相应的指令来应用软件画出相应的图表 曲线图连续的函数在作图时可以直接用函数来化图，离散的图形利用数组来画图 plot(x,y) 其中xy为相同长度的向量，做出折线图，如果在括号内有多对xy则为做出多条折线在同一幅图中。 fplot（fun,[a,b]） 做出函数fun在区间ab上的图像 plot3（x,y,z）空间曲线图 hold on 在做下一曲线图时保留当前图像，结束时hold off来释放保留的图像 曲面图曲面图和后面还有的网面图，都暂时不做学习，待以后再补充。]]></content>
      <categories>
        <category>MATLAB</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javatcp示例]]></title>
    <url>%2Flanxi.github.io%2F2019%2F04%2F29%2Fjavatcp%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[示例思路 程序分为两个进程和服务器端进程，若要实现通信功能，则需要借助Socket来实现 补充：如果要根据不同的客户端返回不同的信息，可以利用InetAddress类，来获取相应连接的主机或名字的信息，先运行服务器，后运行客户端环境：eclipse+jdk11 程序代码 服务器端代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 public class tcpserver &#123; public static void main(String[] args) &#123; ServerSocket ss = null; OutputStream os = null; InputStream is = null; Socket sclient = null; byte[] buff = null; int len; buff = new byte[1024]; String info; String cinfo; try &#123; ss = new ServerSocket(6000); System.out.println(&quot;等待客户端连接。。。。。&quot;); sclient = ss.accept(); System.out.println(&quot;客户端已连接，来自&quot;+InetAddress.getLocalHost()); is = sclient.getInputStream(); len = is.read(buff); info = new String(buff,0,len); System.out.println(&quot;这是来自客户端的信息:&quot;+info); os = sclient.getOutputStream(); cinfo = &quot;hello &quot;+InetAddress.getLocalHost()+&quot; i am server.&quot;; os.write(cinfo.getBytes()); os.flush(); Thread.sleep(30); is.close(); os.close(); sclient.close(); ss.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 客户端代码：12345678910111213141516171819202122232425262728293031323334353637383940 public class tcpclient &#123; public static void main(String[] args) &#123; InputStream is = null; OutputStream os = null; Socket clientsocket = null; byte[] buff = null; int len ; String info = &quot;hello i am client!!!!!&quot;; try &#123; //准备连接服务器 System.out.println(&quot;准备连接服务器。。。。&quot;); clientsocket = new Socket(&quot;127.0.0.1&quot;,6000); System.out.println(&quot;准备向服务器发送数据。。。。&quot;); os = clientsocket.getOutputStream();//发送数据 os.write(info.getBytes()); os.flush(); //接收数据 System.out.println(&quot;准备接收服务器数据......&quot;); buff = new byte[1024]; is = clientsocket.getInputStream(); len = is.read(buff); String reinfo = new String(buff,0,len); System.out.println(&quot;这是来自服务器的信息：&quot;+reinfo); os.close(); is.close(); clientsocket.close(); System.out.println(&quot;bye&quot;); &#125; catch (UnknownHostException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matlab学习笔记--入门（一）]]></title>
    <url>%2Flanxi.github.io%2F2019%2F04%2F28%2FMatlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[matlab入门 数据和变量 数组和运算 字符串 元胞和结构 在指令窗口可以做一些简单的计算 数据和变量表达式 几个表达式之间可以用分号或者逗号连接，分号连接不显示运算的结果。 在运算式子结束的时候可用空格+…之后回车在下一行继续书写 %后面写注释 数据显示格式默认数据显示格式为short 整数———整数 实数———小数点后4位 有效数字超出范围————科学计数法 可以利用format进行格式化 格式为： format + 需格式化的类型 ； 变量 复数复数可以直接输入进行计算 示例 a = 1 + 2 * i; 问题：-8开三次根出现一个复数，如何解决？ 预定义变量 i和j，是虚数单位 pi 为圆周率 eps 为浮点识别精度 realmin 为最小正实数，小于其为0 realmax 为最大正实数，大于其为无穷 Inf 为无穷大 NaN 为没有意义的数 可以对其重新赋值，同时clear后初始化 用户变量 whos 查看当前workspace的所有变量 clear 清除所有变量或者指定某一个变量 ans为没有指定变量名的变量 数据MAT文件 使用 load + 文件名来读取相应的文件，mat文件为二进制文件 数组及其运算数组的输入和分析 matlab 中的数组是按列来计算的 数组示例 a = [1,2,3;4,5,6;7,8,9] 等价于 a = [1 2 3 4 5 6 7 8 9] 可以使用等差数列构造一维数组 xxx = 初值：增量：终值 length（）用于查询一维数组的长度 size（）用于查询多维数组的大小 a（：）用于把数组中的数据按顺序，列出为列项量 a（[x,y] [x, y]）提取出xy行，xy列的数组，返回一个新的数组 a（2，：）提取a的整个第二行 a [x;y]将两个数组拼接 sum（a）一维数组直接求和，二维数组按列求和 数组运算 数组的加减A+B/A-B 数组乘A.*B 数组乘方A.^B 数组除法A./B OR A.\B 数学函数 常规数学函数 sin / cos / tan / cot / asin / acos / sqrt / exp / log / floor(向下取整) / ceil（向上取整） / abs（绝对值） / factorial（阶乘） / 关系和逻辑运算真用1，假用0来表示，其余规则与c和java一致，非用~来表示 字符串，元胞和结构字符串 字符串直接用单引号包围 size()用来求字符串长度 eval()可以执行字符串中的计算式 字符串可以用ascll码换算 拼接字符串示例 [a,’.’,b,’.’] 字符串和数字之间可以用来转换 num2str str2num 元胞和结构 字符串可以通过char（）来转化为字符数组，会自动补齐 不同类型，尺寸的数组通过加大括号来表示为一个元胞，多个元胞形成数组 示例ac1={‘first’;1:3} ac2={‘second’;[1 2;3 4]} ac=[ac1,ac2] ac = ‘first’ ‘second’ [1*3 double] [2*2 double] ac()查询元素 ac[]查询元素具体内容 结构通过域来定义，这里可以理解为结构体的概念，几个结构可以合成一个结构数组然后域名一致示例省略，很重要 元胞数组和结构数组之间的转换 struct2cell cell2struct]]></content>
      <categories>
        <category>MATLAB</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MD使用介绍]]></title>
    <url>%2Flanxi.github.io%2F2019%2F04%2F26%2FMD%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[主要特点 自动生成目录 代码块高亮 引用展示 表格插入 图片插入 强调显示 列表显示 自动URL链接 语法标题主要用#来表示标题的等级，从一个开始到六个，继续加多没有格式，只会生成目录，可以闭合 列表无序列表 a b c 用+号在前面来表示，注意需要有一个空格，后面也是 有序列表 ada sad asd 用数字加英文’.’来表示，有序列表和无序列表可以进行嵌套，嵌套用tab来缩进 eg： sad 5446 564 5464 无序同理 引用MD中使用 &gt; 来进行引用 示例： asddaaasda asdad sadas asd Asdasd asdasd 代码块 少量代码，单行使用，直接用`包裹起来就行了 大量代码，需要多行使用，用`包裹起来 连接 行内式 链接的文字放在[]中，链接地址放在随后的()中，链接也可以带title属性，链接地址后面空一格，然后用引号引起来 用[文字]和(地址或地址加上title)来表示 简书,是一个创作社区,任何人均可以在其上进行创作。用户在简书上面可以方便的创作自己的作品,互相交流。 图片和链接的形式差不多，图片的名字放在[]中，图片地址放在随后的()中，title属性（图片地址后面空一格，然后用引号引起来）,注意的是[]前要加上! 分割线分割线可以由* - _（星号，减号，底线）这3个符号的至少3个符号表示，注意至少要3个，且不需要连续，有空格也可以 示例： 表格表格使用 表格的格式不一定要对的非常起，但是为了良好的变成风格，尽量对齐是最好的 分割线后面的冒号表示对齐方式，写在左边表示左对齐，右边为右对齐，两边都写表示居中 用 || 来表示,也就是说两条竖杠等于表格的格子线，就不举例了 其他 一个星号或者是一个下划线包起来，会转换为倾斜，如果是2个，会转换为加粗内容\ or_内容_等等 转义字符用\表示 删除线用内容来表示 提醒自己，千万要加空格在格式和文字之间！！！！！！ 以上就基本的MD语法的简单介绍]]></content>
      <categories>
        <category>hexo博客教程</category>
      </categories>
      <tags>
        <tag>MD使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Myfirstart]]></title>
    <url>%2Flanxi.github.io%2F2019%2F04%2F25%2FMyfirstart%2F</url>
    <content type="text"><![CDATA[#这是这里的第一篇测试文章时间：2019年4月25日]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Flanxi.github.io%2F2019%2F04%2F25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
